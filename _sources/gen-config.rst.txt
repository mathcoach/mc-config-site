***********************************************
Semi-automatic generation of Configuration File
***********************************************


To use this Feature you have to put artifacts ``mc-artifact-annotation`` and ``mc-config-tool-annotation-processor``
to your dependency:

.. code-block:: xml

    <dependency>
        <groupId>io.github.mathcoach</groupId>
        <artifactId>mc-config-annotation</artifactId>
        <version>${mc.config.version}</version>
    </dependency>
    <dependency>
        <groupId>io.github.mathcoach</groupId>
        <artifactId>mc-config-tool-annotation-processor</artifactId>
        <version>${mc.config.version}</version>
    </dependency>

Now you can use the annotations ``@NeedConfig`` and ``@NeedConfigs`` [#f1]_ to denote classes, which need one or more configuration
parameters to work properly.

.. code-block:: java

   @NeedConfig(
       name = DbConnector.DB_URL_KEY,
       description = "JDBC URL to database for myapp",
       sugguestValues = {
           "jdbc:postgresql://locahost:5432/myapp"
       }
   )
   @NeedConfig(
       name = DbConnector.DB_USER_KEY,
       description = "Database user who is authorized to connect to database configured by "
            + DbConnector.DB_URL_KEY
   )
   @NeedConfig(
       name = DbConnector.DB_PASS_KEY,
       description = "Password of user to connect to database configured by " + DbConnector.DB_URL_KEY
   )
   class DbConnector {

       public static final String DB_URL_KEY = "db.url";
       public static final String DB_USER_KEY = "db.username";
       public static final String DB_PASS_KEY = "db.password";

       DataSource getDataSource(EnvConfiguration config) {
           String dbUrl = config.getConfigValue(DB_URL_KEY);
           String dbUser = config.getConfigValue(DB_USER_KEY);
           String dbPass = config.getConfigValue(DB_PASS_KEY);
           // create an instance of DataSource using variables dbUrl, dbUser, dbPass
           // ....
       }
   }


The annotation ``@NeedConfig`` can be used across Java Classes in the project. Documenting about how a class must be configured
can be written near to code.


When these classes are compiled, these annotations are processed and some new classes are generated. This is especially useful if
your project is a library. Your library client (in most case is an application) can not only collect its own configuration information,
but alos information how to configure your library as its runtime.

To collect configuration information which is generated by compiling classes denoted by ``@NeedConfig`` you need to add the
artifact ``mc-config-tool-collector`` to your project. This is applied in most cases of writing applications, very seldom in
case of writing library.

.. code-block:: xml

    <dependency>
        <groupId>de.htwsaar</groupId>
        <artifactId>mc-config-tool-collector</artifactId>
        <version>${mc.config.version}</version>
    </dependency>


For example this code can run at the start up phase of a program. It tries to configure it self. If
the file in ``import = ...`` does not exist, it creates a template file.

.. code-block:: java

    // initialize app
    void initialize() {
        try {
            EnvConfiguration cfg = AppConfig.getConfig() ;
            // Do something with configuration
        } catch (ImportCfgFileNotFound ex) {
            Path configPath = ex.getImportedPath();
            createConfigTemplateFile(configPath);
        }
    }

    private void createConfigTemplateFile(Path configPath) {
        Map<String, ConfigEntries.Entry> usedConfigParameter = ConfigCollector.collectConfigAsMap();
        // iterate over usedConfigParameter and print it out
        OutputStream out = ... ; // create an appropriate Stream according to configPath
        try (PrintWriter p = new PrintWriter(out)) {
            p.println("# copy this template to " + configPath.toString() );
            p.println();
            usedConfigParameter().forEach( (key, value) ->  {
                p// config template
                p.print(key);
                p.println(" = ");
                // comment about used in
                p.println("# Used in");
                Set<ConfigEntries.ConfigUser> useIn = value.useIn();
                useIn.forEach(user -> {
                    p.print("# * ");
                    p.println(user.name);
                    String[] lines = user.description.split("\\n");
                    for (int i = 0; i < lines.length; ++i) {
                        p.print("#     ");
                        p.println(lines[i]);
                    }
                });
                // possible values
                final Set<String> suggestValue = value.suggestValue();
                if(!suggestValue.isEmpty()) {
                    p.println("# Suggest:");
                    suggestValue.forEach( v-> {
                        p.print("# ");
                        p.print(key);
                        p.print("=");
                        p.println(v);
                    });
                }
                // end
                p.println();
            });
        } catch(IOException ex) {
            // Tell user, the app cannot create a template file for config
            // ....
        }
    }



.. note::
    This code example is kept simple. Its object is to demonstrate how to use the class ``ConfigEntries.Entry`` to
    get retrieve configuration information. You must adapt this example to your own situation.



.. rubric:: Footnotes

.. [#f1] ``@NeedConfig`` `<apidocs/de/htwsaar/config/annotation/NeedConfig.html>`_
.. [#f2] ``EnvConfiguration`` `<apidocs/de/htwsaar/config/EnvConfiguration.html>`_
.. [#f3] ``ImportCfgFileNotFound`` `<apidocs/de/htwsaar/config/ImportCfgFileNotFound.html>`_
.. [#f4] ``ConfigCollector`` `<apidocs/de/htwsaar/config/ConfigCollector.html>`_
.. [#f5] ``ConfigEntries.Entry`` `<apidocs/de/htwsaar/config/ConfigEntries.Entry.html>`_
.. [#f6] ``ConfigEntries.ConfigUser`` `<apidocs/de/htwsaar/config/ConfigEntries.ConfigUser.html>`_


